# 番茄鐘功能修正與新增說明（第二版）

## 修正日期
2025年10月1日

---

## 問題修正

### ✅ 問題 2 的深度修正：任務狀態不會更新為「進行中」

#### 問題分析
經過第一次修正後，問題仍然存在。深入分析後發現：

1. **後端限制問題：**
   - 原本的後端邏輯只會在任務狀態為 `Pending` 時才更新為 `InProgress`
   - 如果使用者暫停後再開始，或者其他情況下，任務已經是 `InProgress` 狀態，就不會再次更新
   - 這導致前端無法正確同步狀態

2. **前端時序問題：**
   - 即使後端更新了狀態，前端也需要等待 API 回應後才能看到變化
   - 這造成使用者體驗不佳

#### 解決方案

**後端修正（PomodoroController.cs）：**

```csharp
// 修正前：只更新 Pending 狀態的任務
if (task != null && task.Status == Models.TaskStatus.Pending)
{
    task.Status = Models.TaskStatus.InProgress;
    await _dataService.UpdateTaskAsync(task);
}

// 修正後：更新所有非已完成的任務
if (task != null && task.Status != Models.TaskStatus.Completed)
{
    task.Status = Models.TaskStatus.InProgress;
    await _dataService.UpdateTaskAsync(task);
    _logger.LogInformation("任務 {TaskId} 狀態已更新為 InProgress", task.Id);
}
```

**前端優化（pomodoro.js - startTaskSession）：**

```javascript
async startTaskSession(taskId) {
    const task = this.tasks.find(t => t.id === taskId);
    if (!task) return;
    
    // 設定當前任務
    this.timer.currentTaskId = taskId;
    document.getElementById('currentTaskName').textContent = task.taskName;
    
    // 立即更新任務狀態為進行中（前端先更新，提升使用者體驗）
    if (task.status !== 2) { // 2 = Completed
        task.status = 1; // 1 = InProgress
        this.renderTasks(); // 重新渲染任務列表，顯示「暫停」按鈕
    }
    
    // 重設計時器為工作時間
    this.resetTimer('Work');
    
    // 立即開始計時器倒數
    this.startTimer();
    
    // 顯示通知
    this.showNotification(`開始任務：${task.taskName}`, 'success');
}
```

**關鍵改進：**
- 前端在呼叫 API 之前就先更新任務狀態和 UI
- 這樣使用者可以立即看到變化，而不需要等待 API 回應
- 後端會確保狀態正確同步到資料庫

---

## 新功能實作

### 🎯 功能：任務開始後顯示「暫停」按鈕

#### 需求說明
當任務點選開始後，任務清單中該任務的「開始」按鈕應該變成「暫停」按鈕，提升使用者體驗。

#### 實作細節

**1. 修改 renderTaskItem 函式（pomodoro.js）：**

```javascript
renderTaskItem(task) {
    // ... 狀態處理程式碼 ...
    
    // 檢查這個任務是否為當前正在倒數的任務
    const isCurrentTask = this.timer.currentTaskId === task.id;
    const isTimerRunning = this.timer.isRunning;
    
    // 決定顯示「開始」還是「暫停」按鈕
    let actionButton = '';
    if (statusString !== 'Completed') {
        if (isCurrentTask && isTimerRunning) {
            // 當前任務且計時器正在執行：顯示「暫停」按鈕
            actionButton = `
                <button class="task-btn btn-pause" onclick="PomodoroApp.pauseTimer()">
                    <i class="fas fa-pause"></i> 暫停
                </button>
            `;
        } else {
            // 其他情況：顯示「開始」按鈕
            actionButton = `
                <button class="task-btn btn-start" onclick="PomodoroApp.startTaskSession('${task.id}')">
                    <i class="fas fa-play"></i> 開始
                </button>
            `;
        }
    }
    
    // 為當前任務添加特殊樣式和執行中圖示
    return `
        <div class="task-item status-${statusString.toLowerCase()} ${isCurrentTask ? 'current-task' : ''}" data-task-id="${task.id}">
            <div class="task-info">
                <div class="task-title">
                    ${isCurrentTask && isTimerRunning ? '<i class="fas fa-spinner fa-pulse"></i> ' : ''}
                    ${this.escapeHtml(task.taskName)}
                </div>
                <!-- ... 其他內容 ... -->
            </div>
            <div class="task-actions">
                ${actionButton}
                <!-- ... 其他按鈕 ... -->
            </div>
        </div>
    `;
}
```

**2. 確保按鈕狀態即時更新：**

在 `startTimer()` 和 `pauseTimer()` 函式中新增 `this.renderTasks()`：

```javascript
async startTimer() {
    // ... 計時器啟動邏輯 ...
    
    this.updateControlButtons();
    document.getElementById('timerStatus').textContent = '專注中...';
    
    // 重新渲染任務列表，更新按鈕狀態
    this.renderTasks();
}

pauseTimer() {
    // ... 暫停邏輯 ...
    
    this.updateControlButtons();
    document.getElementById('timerStatus').textContent = '已暫停';
    
    // 重新渲染任務列表，將「暫停」按鈕變回「開始」按鈕
    this.renderTasks();
}
```

**3. 新增視覺效果（pomodoro.css）：**

```css
/* 當前正在倒數的任務 */
.task-item.current-task {
    background: rgba(102, 126, 234, 0.15);
    border-color: var(--color-work-primary);
    box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
    animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% {
        box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
    }
    50% {
        box-shadow: 0 0 30px rgba(102, 126, 234, 0.7);
    }
}

/* 暫停按鈕樣式 */
.task-btn.btn-pause {
    background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);
    color: white;
}

.task-btn.btn-pause:hover {
    background: linear-gradient(135deg, #ffb300 0%, #ff8f00 100%);
}
```

#### 功能特色

1. **智慧按鈕切換：**
   - 當任務開始倒數時，「開始」按鈕自動變成「暫停」按鈕
   - 暫停後又會變回「開始」按鈕
   - 其他任務保持「開始」按鈕

2. **視覺回饋：**
   - 正在執行的任務有脈搏動畫效果
   - 任務標題前方顯示旋轉的執行圖示 🔄
   - 特殊的背景色和陰影效果

3. **直覺操作：**
   - 點擊「暫停」按鈕可以直接暫停當前任務
   - 不需要移動到番茄鐘區域操作

---

## 完整執行流程

### 使用者操作流程：

1. **建立任務**
   - 使用者輸入任務名稱和預估番茄數
   - 任務顯示在「待處理」列表中

2. **開始任務**
   - 點擊任務的「開始」按鈕
   - ✨ **立即發生的變化：**
     - 任務狀態立即變為「進行中」
     - 任務移到「進行中」篩選列表
     - 「開始」按鈕變成「暫停」按鈕
     - 任務卡片出現脈搏動畫
     - 任務標題前出現旋轉圖示
     - 番茄鐘開始倒數

3. **暫停任務**
   - 點擊任務的「暫停」按鈕（或番茄鐘的暫停按鈕）
   - ✨ **立即發生的變化：**
     - 計時器暫停
     - 「暫停」按鈕變回「開始」按鈕
     - 任務仍保持「進行中」狀態
     - 移除旋轉圖示

4. **繼續任務**
   - 點擊番茄鐘的「開始」按鈕
   - 計時器繼續倒數
   - 「開始」按鈕變回「暫停」按鈕

5. **切換任務**
   - 點擊另一個任務的「開始」按鈕
   - 前一個任務的「暫停」按鈕變回「開始」按鈕
   - 新任務顯示「暫停」按鈕並開始倒數

---

## 檔案變更清單

### 後端檔案
- `/Users/qiuzili/DemoMVC/DemoMVC/Controllers/PomodoroController.cs`
  - ✅ 修正 `StartSession` 方法的狀態更新邏輯
  - ✅ 新增日誌記錄

### 前端檔案
- `/Users/qiuzili/DemoMVC/DemoMVC/wwwroot/js/pomodoro.js`
  - ✅ 修正 `startTaskSession()` - 立即更新前端狀態
  - ✅ 修正 `renderTaskItem()` - 動態顯示開始/暫停按鈕
  - ✅ 修正 `startTimer()` - 新增任務列表重新渲染
  - ✅ 修正 `pauseTimer()` - 新增任務列表重新渲染

- `/Users/qiuzili/DemoMVC/DemoMVC/wwwroot/css/pomodoro.css`
  - ✅ 新增 `.current-task` 樣式（脈搏動畫）
  - ✅ 新增 `.btn-pause` 樣式
  - ✅ 新增 `@keyframes pulse` 動畫

---

## 測試案例

### 測試 1：任務狀態更新
1. ✅ 建立一個新任務（狀態：待處理）
2. ✅ 點擊任務的「開始」按鈕
3. ✅ **預期結果：**
   - 任務立即顯示在「進行中」列表
   - 「開始」按鈕變成「暫停」按鈕
   - 番茄鐘開始倒數

### 測試 2：暫停按鈕功能
1. ✅ 開始一個任務
2. ✅ 點擊任務的「暫停」按鈕
3. ✅ **預期結果：**
   - 計時器暫停
   - 「暫停」按鈕變回「開始」按鈕
   - 任務保持「進行中」狀態

### 測試 3：切換任務
1. ✅ 開始任務 A（顯示「暫停」按鈕）
2. ✅ 點擊任務 B 的「開始」按鈕
3. ✅ **預期結果：**
   - 任務 A 的「暫停」按鈕變回「開始」按鈕
   - 任務 B 顯示「暫停」按鈕並開始倒數
   - 兩個任務都在「進行中」列表

### 測試 4：視覺效果
1. ✅ 開始一個任務
2. ✅ **預期結果：**
   - 任務卡片有脈搏動畫（陰影大小變化）
   - 任務標題前有旋轉圖示
   - 暫停按鈕是橙黃色漸層

### 測試 5：重複開始任務
1. ✅ 開始一個任務
2. ✅ 暫停任務
3. ✅ 再次點擊同一個任務的「開始」按鈕
4. ✅ **預期結果：**
   - 任務繼續倒數
   - 保持「進行中」狀態
   - 不會建立重複的工作階段

---

## 建置狀態

✅ **建置成功**（2025年10月1日）
- 0 個警告
- 0 個錯誤
- 編譯時間：~2 秒

---

## 技術亮點

### 1. 樂觀更新（Optimistic Update）
前端在等待 API 回應之前就先更新 UI，提供即時的使用者回饋。

### 2. 狀態驅動 UI
按鈕的顯示完全由應用程式狀態決定（`timer.currentTaskId` 和 `timer.isRunning`），確保 UI 一致性。

### 3. 視覺回饋
透過動畫、顏色和圖示的組合，讓使用者清楚知道當前任務的執行狀態。

### 4. 防呆設計
- 已完成的任務不會顯示開始/暫停按鈕
- 後端確保不會將已完成的任務改為進行中
- 前端即時同步狀態，避免不一致

---

## 使用者體驗改善總結

| 改善項目 | 改善前 | 改善後 |
|---------|--------|--------|
| 任務狀態更新 | 需要重新載入頁面才能看到 | 立即顯示在「進行中」列表 |
| 按鈕狀態 | 永遠顯示「開始」 | 智慧切換「開始」/「暫停」 |
| 操作便利性 | 需要在兩個區域點擊按鈕 | 在任務列表直接暫停 |
| 視覺識別 | 無法區分正在執行的任務 | 脈搏動畫 + 旋轉圖示 |
| 回應速度 | 等待 API 回應 | 樂觀更新，立即回饋 |

---

## 未來改進建議

1. **離線支援：** 使用 Service Worker 快取資料，支援離線操作
2. **快捷鍵：** 新增鍵盤快捷鍵（如空白鍵暫停/繼續）
3. **通知功能：** 使用瀏覽器原生通知 API，而非 alert
4. **統計圖表：** 新增視覺化的統計圖表
5. **任務拖曳：** 支援拖曳排序任務優先順序
