# 番茄鐘功能修正說明

## 修正日期
2025年10月1日

## 問題描述

### 問題 1：任務清單的「開始」按鈕不會啟動計時器
**現象：** 點選任務清單中的「開始」按鈕後，番茄鐘不會開始倒數，需要再次點選番茄鐘區域的「開始」按鈕才會開始倒數。

**原因：** `startTaskSession(taskId)` 函式只設定了當前任務和重設計時器，但沒有呼叫 `startTimer()` 來啟動倒數。

### 問題 2：任務狀態不會更新為「進行中」
**現象：** 已經開始倒數，但是在「任務清單」的「進行中」篩選列表中看不到正在倒數的任務。

**原因：** 
1. `startSession()` 函式呼叫後端 API 開始工作階段，後端會更新任務狀態為 InProgress
2. 但前端沒有重新載入任務列表，所以看不到狀態變化

## 解決方案

### 修改 1：`startTaskSession` 函式（第 329-343 行）
```javascript
async startTaskSession(taskId) {
    const task = this.tasks.find(t => t.id === taskId);
    if (!task) return;
    
    // 設定當前任務
    this.timer.currentTaskId = taskId;
    document.getElementById('currentTaskName').textContent = task.taskName;
    
    // 重設計時器為工作時間
    this.resetTimer('Work');
    
    // 立即開始計時器倒數
    this.startTimer();
    
    // 顯示通知
    this.showNotification(`開始任務：${task.taskName}`, 'success');
}
```

**變更：**
- 新增 `async` 關鍵字
- 在函式最後呼叫 `this.startTimer()` 來立即開始倒數
- 新增通知訊息，讓使用者知道任務已開始

### 修改 2：`startTimer` 函式（第 434-457 行）
```javascript
async startTimer() {
    if (this.timer.isRunning) return;
    
    // 如果沒有選擇任務，提示使用者
    if (!this.timer.currentTaskId) {
        this.showNotification('請先選擇一個任務', 'warning');
        return;
    }
    
    // 如果是新開始（不是暫停後繼續）
    if (!this.timer.isPaused) {
        await this.startSession();  // 等待 session 開始並載入任務
    }
    
    this.timer.isRunning = true;
    this.timer.isPaused = false;
    
    this.timer.interval = setInterval(() => {
        this.tick();
    }, 1000);
    
    this.updateControlButtons();
    document.getElementById('timerStatus').textContent = '專注中...';
}
```

**變更：**
- 新增 `async` 關鍵字
- 使用 `await this.startSession()` 等待工作階段開始並完成任務列表的重新載入

### 修改 3：`startSession` 函式（第 551-573 行）
```javascript
async startSession() {
    try {
        const response = await fetch('/Pomodoro/StartSession', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                taskId: this.timer.currentTaskId,
                sessionType: this.timer.currentSessionType
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            this.timer.currentSessionId = result.data.id;
            console.log('工作階段已開始:', result.data);
            
            // 重新載入任務以更新狀態（伺服器端會將任務狀態更新為 InProgress）
            await this.loadTasks();
        }
    } catch (error) {
        console.error('開始工作階段失敗:', error);
    }
}
```

**變更：**
- 在成功開始工作階段後，呼叫 `await this.loadTasks()` 重新載入任務列表
- 這樣前端就能顯示後端更新的任務狀態（InProgress）

## 執行流程

### 修正前
1. 使用者點擊任務的「開始」按鈕
2. `startTaskSession()` 設定任務並重設計時器
3. **停在這裡，等待使用者再次點擊番茄鐘的「開始」按鈕**
4. 使用者點擊番茄鐘的「開始」按鈕
5. `startTimer()` 開始倒數
6. `startSession()` 呼叫後端 API（後端更新狀態為 InProgress）
7. **前端沒有重新載入，看不到狀態變化**

### 修正後
1. 使用者點擊任務的「開始」按鈕
2. `startTaskSession()` 設定任務並重設計時器
3. **自動呼叫 `startTimer()` 開始倒數**
4. `startTimer()` 等待 `startSession()` 完成
5. `startSession()` 呼叫後端 API（後端更新狀態為 InProgress）
6. **`startSession()` 重新載入任務列表，前端顯示更新後的狀態**
7. 計時器開始倒數

## 測試建議

### 測試案例 1：點擊任務的開始按鈕
1. 建立一個新任務
2. 點擊任務的「開始」按鈕
3. **預期結果：**
   - 番茄鐘立即開始倒數
   - 顯示通知訊息「開始任務：[任務名稱]」
   - 當前任務顯示正確的任務名稱

### 測試案例 2：任務狀態更新
1. 建立一個新任務（狀態：待處理）
2. 點擊任務的「開始」按鈕
3. 等待 1-2 秒（讓 API 呼叫完成）
4. 點擊「進行中」篩選按鈕
5. **預期結果：**
   - 任務出現在「進行中」列表中
   - 任務的狀態標籤顯示為「進行中」

### 測試案例 3：暫停後繼續
1. 開始一個任務
2. 點擊「暫停」按鈕
3. 點擊「開始」按鈕繼續
4. **預期結果：**
   - 計時器繼續倒數
   - 不會建立新的工作階段
   - 任務狀態保持「進行中」

## 後端支援

後端已經在 `PomodoroController.StartSession` 方法中實作了任務狀態更新邏輯：

```csharp
// 如果是工作階段，更新任務狀態
if (request.SessionType == SessionType.Work)
{
    var task = await _dataService.GetTaskByIdAsync(request.TaskId);
    if (task != null && task.Status == Models.TaskStatus.Pending)
    {
        task.Status = Models.TaskStatus.InProgress;
        await _dataService.UpdateTaskAsync(task);
    }
}
```

這段程式碼會在開始工作階段時，將任務狀態從 Pending 更新為 InProgress。

## 檔案變更清單

- `/Users/qiuzili/DemoMVC/DemoMVC/wwwroot/js/pomodoro.js`
  - `startTaskSession()` 函式修改
  - `startTimer()` 函式修改
  - `startSession()` 函式修改

## 建置狀態

✅ 建置成功（2025年10月1日）
- 0 個警告
- 0 個錯誤
